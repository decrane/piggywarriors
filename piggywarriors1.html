<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Piggy Warriors</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 0;
            padding: 20px;
            background-color: #f0f8ff;
            transition: background-color 0.4s ease, color 0.4s ease;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        h1 {
            color: #333;
            margin-bottom: 30px;
        }
        .waffle-btn {
            display: inline-block;
            margin-top: 16px;
            padding: 12px 18px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            background: #faad14;
            color: #222;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
            transition: transform 0.15s ease, background-color 0.2s ease, box-shadow 0.2s ease;
        }
        .waffle-btn:hover {
            transform: translateY(-1px);
            background: #ffc53d;
            box-shadow: 0 6px 14px rgba(0,0,0,0.2);
        }
        .intro {
            font-size: 18px;
            margin-bottom: 30px;
        }
        .piggy-image {
            width: 50%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            margin: 20px 0;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .piggy-image:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
        }
        
        .image-container {
            position: relative;
            display: inline-block;
            width: 50%;
        }
        
        .piggy-image, .piggy-warrior {
            width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            margin: 20px 0;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .piggy-warrior {
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            transform: rotateY(90deg);
        }
        
        .image-container:hover .piggy-image {
            opacity: 0;
            transform: rotateY(-90deg);
        }
        
        .image-container:hover .piggy-warrior {
            opacity: 1;
            transform: rotateY(0deg);
        }

        

        /* Full-screen fireworks (click to launch) */
        .fireworks-full-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 999;
        }

        /* Dark mode toggle when fireworks run */
        body.dark-mode {
            background-color: #001126;
            color: #e6f7ff;
        }
        body.dark-mode h1 {
            color: #e6f7ff;
        }
        body.dark-mode .waffle-btn {
            background: #ffd666;
            color: #111;
        }

        /* T-Rex game styles */
        .game-container {
            margin-top: 24px;
        }
        #trexCanvas {
            width: 100%;
            max-width: 800px;
            height: 220px;
            background: #f7f7f7;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            outline: none;
            border: 1px solid #e8e8e8;
        }
        .game-instructions {
            margin-top: 8px;
            font-size: 14px;
            color: #666;
        }
        body.dark-mode #trexCanvas {
            background: #0a1b33;
            border-color: #112a4d;
        }
        body.dark-mode .game-instructions {
            color: #aac6e6;
        }

        /* Sandwich Predictor */
        .food-section {
            margin-top: 28px;
        }
        .food-title {
            margin: 0 0 8px 0;
        }
        .food-controls {
            margin-bottom: 10px;
        }
        .upload-btn {
            display: inline-block;
            padding: 10px 14px;
            font-size: 14px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            background: #40a9ff;
            color: #fff;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.12);
            transition: transform 0.15s ease, background-color 0.2s ease, box-shadow 0.2s ease;
        }
        .upload-btn:hover { transform: translateY(-1px); background: #69c0ff; box-shadow: 0 6px 14px rgba(0,0,0,0.18); }
        .food-card { display: inline-block; }
        .food-image {
            width: 100%;
            max-width: 360px;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        .food-image:hover { transform: scale(1.02); }
        .food-hint { margin-top: 8px; font-size: 14px; color: #666; }
        .food-result { margin-top: 8px; font-size: 16px; font-weight: 700; color: #333; }
        body.dark-mode .upload-btn { background: #69c0ff; color: #001126; }
        body.dark-mode .food-hint { color: #aac6e6; }
        body.dark-mode .food-result { color: #e6f7ff; }

        /* Wheel of Animals */
        .wheel-section { margin-top: 28px; }
        .wheel-title { margin: 0 0 10px 0; }
        .wheel-wrap { display: inline-flex; flex-direction: column; align-items: center; gap: 10px; }
        #animalWheel {
            width: 400px;
            height: 400px;
            display: block;
        }
        #countryWheel {
            width: 400px;
            height: 400px;
            display: block;
        }
        #jobWheel {
            width: 400px;
            height: 400px;
            display: block;
        }
        #personWheel {
            width: 400px;
            height: 400px;
            display: block;
        }
        #numberWheel {
            width: 400px;
            height: 400px;
            display: block;
        }
        .spin-btn {
            display: inline-block;
            padding: 10px 16px;
            font-size: 14px;
            font-weight: 700;
            border: none;
            border-radius: 999px;
            background: #73d13d;
            color: #0f2a0f;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.12);
            transition: transform 0.15s ease, background-color 0.2s ease, box-shadow 0.2s ease;
        }
        .spin-btn:hover { transform: translateY(-1px); background: #95de64; box-shadow: 0 6px 14px rgba(0,0,0,0.18); }
        .wheel-result { margin-top: 6px; font-weight: 700; color: #333; }
        body.dark-mode .wheel-result { color: #e6f7ff; }
    </style>
</head>
<body>
    <div class="container">
        <h1>HELLO FELLOW WARRIORS!!! </h1>
        
        <div class="intro">
            My name is Barrett. I am a piggy warrior along with four other 
            Piggy Warriors: Rocky Road, Ganache, Jeff, and Fish Fry. 
        </div>
        
        <div class="image-container">
            <img src="https://media.4-paws.org/9/4/f/5/94f5197df88687ce362e32f23b926f0a246c1b54/VIER%20PFOTEN_2016-11-16_028%20%281%29-1843x1275.jpg" 
                 alt="Piggy Warriors" 
                 class="piggy-image">
            <img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRIF-rxfIfjYdOzTXBT4D5xWcp8cEJ7C03x1f_2qQVg22PD3rzDSVqwNCRGrQ9M37EgaTI&usqp=CAU" 
                 alt="Piggy Warrior" 
                 class="piggy-warrior">
        </div>
        <button id="waffleBtn" class="waffle-btn" type="button">Tell me something</button>
    </div>

    <div class="container">
        <div class="game-container">
            <canvas id="trexCanvas" width="800" height="220" tabindex="0" aria-label="T-Rex Runner Game"></canvas>
            <div class="game-instructions">Press Space/Up to jump, Down to duck. Click the game box if keys donâ€™t respond.</div>
        </div>
    </div>

    <div class="container">
        <div class="food-section">
            <h2 class="food-title">Sandwich Predictor</h2>
            <div class="food-controls">
                <button class="upload-btn" type="button" id="sandwichUploadBtn">Upload sandwich picture</button>
                <input id="sandwichUpload" type="file" accept="image/*" style="display:none">
            </div>
            <div class="food-card">
                <img id="sandwichImage" class="food-image" alt="Sandwich"
                     src="https://images.unsplash.com/photo-1540189549336-e6e99c3679fe?q=80&w=1200&auto=format&fit=crop" />
                <div class="food-hint">Click the sandwich to get a random food!</div>
                <div id="randomFoodResult" class="food-result"></div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="wheel-section">
            <h2 class="wheel-title">Wheel of Animals</h2>
            <div class="wheel-wrap">
                <canvas id="animalWheel" width="400" height="400" aria-label="Wheel of Animals"></canvas>
                <button id="spinWheelBtn" class="spin-btn" type="button">Spin the wheel</button>
                <div id="animalWheelResult" class="wheel-result"></div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="wheel-section">
            <h2 class="wheel-title">Wheel of Countries</h2>
            <div class="wheel-wrap">
                <canvas id="countryWheel" width="400" height="400" aria-label="Wheel of Countries"></canvas>
                <button id="spinCountryBtn" class="spin-btn" type="button">Spin the wheel</button>
                <div id="countryWheelResult" class="wheel-result"></div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="wheel-section">
            <h2 class="wheel-title">Wheel of Jobs</h2>
            <div class="wheel-wrap">
                <canvas id="jobWheel" width="400" height="400" aria-label="Wheel of Jobs"></canvas>
                <button id="spinJobBtn" class="spin-btn" type="button">Spin the wheel</button>
                <div id="jobWheelResult" class="wheel-result"></div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="wheel-section">
            <h2 class="wheel-title">Wheel of Famous People</h2>
            <div class="wheel-wrap">
                <canvas id="personWheel" width="400" height="400" aria-label="Wheel of Famous People"></canvas>
                <button id="spinPersonBtn" class="spin-btn" type="button">Spin the wheel</button>
                <div id="personWheelResult" class="wheel-result"></div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="wheel-section">
            <h2 class="wheel-title">Wheel of Numbers</h2>
            <div class="wheel-wrap">
                <canvas id="numberWheel" width="400" height="400" aria-label="Wheel of Numbers"></canvas>
                <button id="spinNumberBtn" class="spin-btn" type="button">Spin the wheel</button>
                <div id="numberWheelResult" class="wheel-result"></div>
            </div>
        </div>
    </div>

    
    <canvas class="fireworks-full-canvas"></canvas>
    <script>
        // Full-screen click-to-launch fireworks (inspired by the approach described in the article)
        (function () {
            const canvas = document.querySelector('.fireworks-full-canvas');
            const ctx = canvas.getContext('2d');

            let running = false;
            let rafId = null;
            let seeds = [];
            let particles = [];

            function resize() {
                const dpr = window.devicePixelRatio || 1;
                canvas.width = Math.floor(window.innerWidth * dpr);
                canvas.height = Math.floor(window.innerHeight * dpr);
                canvas.style.width = '100vw';
                canvas.style.height = '100vh';
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            }

            function ensureRunning() {
                if (!running) {
                    running = true;
                    resize();
                    document.body.classList.add('dark-mode');
                    rafId = requestAnimationFrame(step);
                }
            }

            function stop() {
                running = false;
                if (rafId) cancelAnimationFrame(rafId);
                rafId = null;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                document.body.classList.remove('dark-mode');
            }

            function spawnSeed(x, y) {
                const seed = {
                    x,
                    y,
                    vx: (Math.random() - 0.5) * 1.0,
                    vy: -(5 + Math.random() * 3.5),
                    explodeY: y - (120 + Math.random() * 180),
                    lifeMs: 1200,
                };
                seeds.push(seed);
                ensureRunning();
            }

            function explode(x, y) {
                const colors = ['#ff4d4f', '#ffd666', '#73d13d', '#40a9ff', '#9254de', '#fa8c16'];
                const count = 90;
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 4.5;
                    particles.push({
                        x,
                        y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1.0,
                        decay: 0.008 + Math.random() * 0.02,
                        color: colors[Math.floor(Math.random() * colors.length)],
                    });
                }
            }

            function step() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.globalCompositeOperation = 'lighter';

                const gravity = 0.05;
                const drag = 0.992;

                for (let i = seeds.length - 1; i >= 0; i--) {
                    const s = seeds[i];
                    s.vx *= drag;
                    s.vy = s.vy * drag + gravity * 0.6;
                    s.x += s.vx;
                    s.y += s.vy;
                    s.lifeMs -= 16;

                    // draw seed
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, 2, 0, Math.PI * 2);
                    ctx.fill();

                    if (s.y <= s.explodeY || s.lifeMs <= 0) {
                        explode(s.x, s.y);
                        seeds.splice(i, 1);
                    }
                }

                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.vx *= drag;
                    p.vy = p.vy * drag + gravity;
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= p.decay;

                    if (p.life <= 0) {
                        particles.splice(i, 1);
                        continue;
                    }

                    ctx.globalAlpha = Math.max(p.life, 0);
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                if (seeds.length === 0 && particles.length === 0) {
                    stop();
                    return;
                }

                rafId = requestAnimationFrame(step);
            }

            window.addEventListener('resize', () => {
                if (running) resize();
            });

            document.addEventListener('click', (e) => {
                spawnSeed(e.clientX, e.clientY);
            });

            // Expose helpers to trigger fireworks programmatically
            window.launchFireworksAt = function (x, y) {
                ensureRunning();
                explode(x, y);
            };
            window.launchFireworksBurst = function () {
                ensureRunning();
                const w = window.innerWidth;
                const h = window.innerHeight;
                for (let i = 0; i < 3; i++) {
                    spawnSeed(Math.random() * w, h - 20);
                }
            };

            // Trigger full-screen fireworks when pig flips (hover/touch)
            const pigContainer = document.querySelector('.image-container');
            if (pigContainer) {
                const triggerAtCenter = () => {
                    const r = pigContainer.getBoundingClientRect();
                    window.launchFireworksAt(r.left + r.width / 2, r.top + r.height * 0.3);
                };
                pigContainer.addEventListener('mouseenter', triggerAtCenter);
                pigContainer.addEventListener('touchstart', triggerAtCenter, { passive: true });
            }
        })();
    </script>
    <script>
        // Wheel of Numbers
        (function () {
            const canvas = document.getElementById('numberWheel');
            const resultEl = document.getElementById('numberWheelResult');
            const btn = document.getElementById('spinNumberBtn');
            if (!canvas || !resultEl || !btn) return;
            const ctx = canvas.getContext('2d');

            // Numbers 1â€“10 (clearer, bigger slices)
            const numbers = Array.from({ length: 10 }, (_, i) => i + 1);
            const colors = ['#ff9aa2','#ffb7b2','#ffdac1','#e2f0cb','#b5ead7','#c7ceea',
                            '#ffd666','#95de64','#5cdbd3','#69c0ff','#b37feb','#ffa39e','#ffd8bf','#d6e4ff','#d9f7be','#ffe58f','#ffd666','#69c0ff','#b37feb','#b5ead7'];
            const pointerColor = '#333';

            let rotation = 0; // radians
            let spinning = false;

            function drawWheel() {
                const { width, height } = canvas;
                const r = Math.min(width, height) / 2;
                ctx.clearRect(0, 0, width, height);
                
                // Draw background circle to verify full wheel is visible
                ctx.beginPath();
                ctx.arc(width / 2, height / 2, r, 0, Math.PI * 2);
                ctx.fillStyle = '#f0f0f0';
                ctx.fill();
                
                ctx.save();
                ctx.translate(width / 2, height / 2);
                ctx.rotate(rotation);
                const seg = (Math.PI * 2) / numbers.length;
                for (let i = 0; i < numbers.length; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, r - 6, i * seg, (i + 1) * seg);
                    ctx.closePath();
                    ctx.fillStyle = colors[i % colors.length];
                    ctx.fill();

                    ctx.save();
                    ctx.rotate(i * seg + seg / 2);
                    ctx.textAlign = 'right';
                    ctx.fillStyle = '#222';
                    ctx.font = '16px monospace';
                    ctx.fillText(String(numbers[i]), r - 18, 6);
                    ctx.restore();
                }
                ctx.restore();

                // pointer
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2, 6);
                ctx.lineTo(canvas.width / 2 - 10, 26);
                ctx.lineTo(canvas.width / 2 + 10, 26);
                ctx.closePath();
                ctx.fillStyle = pointerColor;
                ctx.fill();
            }

            function spin() {
                if (spinning) return;
                spinning = true;
                resultEl.textContent = '';

                const seg = (Math.PI * 2) / numbers.length;
                const targetIndex = Math.floor(Math.random() * numbers.length);
                const targetAngle = -Math.PI / 2 - (targetIndex * seg + seg / 2);
                const current = rotation % (Math.PI * 2);
                const spins = 4 + Math.floor(Math.random() * 2);
                let delta = targetAngle - current + spins * Math.PI * 2;

                const duration = 2200 + Math.random() * 600; // ms
                const start = performance.now();
                const startRot = rotation;

                function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

                function step(now) {
                    const t = Math.min(1, (now - start) / duration);
                    const eased = easeOutCubic(t);
                    rotation = startRot + delta * eased;
                    drawWheel();
                    if (t < 1) requestAnimationFrame(step); else {
                        spinning = false;
                        const landed = ((-rotation - Math.PI / 2) % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2);
                        const index = Math.floor(landed / seg);
                        const picked = numbers[index % numbers.length];
                        resultEl.textContent = `Random number: ${picked}`;
                    }
                }
                requestAnimationFrame(step);
            }

            function scaleForDPR() {
                // Set canvas to exact 400x400 size without DPR scaling
                canvas.width = 400;
                canvas.height = 400;
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                drawWheel();
            }
            window.addEventListener('resize', scaleForDPR);
            scaleForDPR();

            btn.addEventListener('click', spin);
            canvas.addEventListener('click', spin);
        })();
    </script>
    <script>
        // Wheel of Famous People
        (function () {
            const canvas = document.getElementById('personWheel');
            const resultEl = document.getElementById('personWheelResult');
            const btn = document.getElementById('spinPersonBtn');
            if (!canvas || !resultEl || !btn) return;
            const ctx = canvas.getContext('2d');

            const people = [
                'Albert Einstein','Marie Curie','Leonardo da Vinci','William Shakespeare','Nelson Mandela',
                'Martin Luther King Jr.','Amelia Earhart','Florence Nightingale','Isaac Newton','Galileo Galilei',
                'Rosa Parks','Oprah Winfrey','Michael Jordan','Serena Williams','BeyoncÃ©','Taylor Swift','Barrett Crane'
            ];
            const colors = ['#ff9aa2','#ffb7b2','#ffdac1','#e2f0cb','#b5ead7','#c7ceea',
                            '#ffd666','#95de64','#5cdbd3','#69c0ff','#b37feb','#ffa39e','#ffd8bf','#d6e4ff','#d9f7be','#ffe58f'];
            const pointerColor = '#333';

            let rotation = 0; // radians
            let spinning = false;

            function drawWheel() {
                const { width, height } = canvas;
                const r = Math.min(width, height) / 2;
                ctx.clearRect(0, 0, width, height);
                
                // Draw background circle to verify full wheel is visible
                ctx.beginPath();
                ctx.arc(width / 2, height / 2, r, 0, Math.PI * 2);
                ctx.fillStyle = '#f0f0f0';
                ctx.fill();
                
                ctx.save();
                ctx.translate(width / 2, height / 2);
                ctx.rotate(rotation);
                const seg = (Math.PI * 2) / people.length;
                for (let i = 0; i < people.length; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, r - 6, i * seg, (i + 1) * seg);
                    ctx.closePath();
                    ctx.fillStyle = colors[i % colors.length];
                    ctx.fill();

                    ctx.save();
                    ctx.rotate(i * seg + seg / 2);
                    ctx.textAlign = 'right';
                    ctx.fillStyle = '#222';
                    ctx.font = '13px sans-serif';
                    const label = people[i];
                    ctx.fillText(label, r - 18, 5);
                    ctx.restore();
                }
                ctx.restore();

                // pointer
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2, 6);
                ctx.lineTo(canvas.width / 2 - 10, 26);
                ctx.lineTo(canvas.width / 2 + 10, 26);
                ctx.closePath();
                ctx.fillStyle = pointerColor;
                ctx.fill();
            }

            function spin() {
                if (spinning) return;
                spinning = true;
                resultEl.textContent = '';

                const seg = (Math.PI * 2) / people.length;
                const targetIndex = Math.floor(Math.random() * people.length);
                const targetAngle = -Math.PI / 2 - (targetIndex * seg + seg / 2);
                const current = rotation % (Math.PI * 2);
                const spins = 4 + Math.floor(Math.random() * 2);
                let delta = targetAngle - current + spins * Math.PI * 2;

                const duration = 2200 + Math.random() * 600; // ms
                const start = performance.now();
                const startRot = rotation;

                function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

                function step(now) {
                    const t = Math.min(1, (now - start) / duration);
                    const eased = easeOutCubic(t);
                    rotation = startRot + delta * eased;
                    drawWheel();
                    if (t < 1) requestAnimationFrame(step); else {
                        spinning = false;
                        const landed = ((-rotation - Math.PI / 2) % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2);
                        const index = Math.floor(landed / seg);
                        const picked = people[index % people.length];
                        if (picked === 'Barrett Crane') {
                            resultEl.textContent = 'ðŸŽ‰ YOU WIN! You got Barrett Crane! ðŸŽ‰';
                            if (window.launchFireworksBurst) window.launchFireworksBurst();
                        } else {
                            resultEl.textContent = `Random famous person: ${picked}`;
                        }
                    }
                }
                requestAnimationFrame(step);
            }

            function scaleForDPR() {
                // Set canvas to exact 400x400 size without DPR scaling
                canvas.width = 400;
                canvas.height = 400;
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                drawWheel();
            }
            window.addEventListener('resize', scaleForDPR);
            scaleForDPR();

            btn.addEventListener('click', spin);
            canvas.addEventListener('click', spin);
        })();
    </script>
    <script>
        // Wheel of Jobs
        (function () {
            const canvas = document.getElementById('jobWheel');
            const resultEl = document.getElementById('jobWheelResult');
            const btn = document.getElementById('spinJobBtn');
            if (!canvas || !resultEl || !btn) return;
            const ctx = canvas.getContext('2d');

            const jobs = [
                'Doctor','Teacher','Engineer','Artist','Chef','Pilot','Firefighter','Police Officer','Nurse','Scientist',
                'Musician','Writer','Photographer','Farmer','Software Developer','Designer','Mechanic','Carpenter','Electrician','Dentist'
            ];
            const colors = ['#ff9aa2','#ffb7b2','#ffdac1','#e2f0cb','#b5ead7','#c7ceea',
                            '#ffd666','#95de64','#5cdbd3','#69c0ff','#b37feb','#ffa39e','#ffd8bf','#d6e4ff','#d9f7be','#ffd666','#69c0ff','#b37feb','#b5ead7','#ffdac1'];
            const pointerColor = '#333';

            let rotation = 0; // radians
            let spinning = false;

            function drawWheel() {
                const { width, height } = canvas;
                const r = Math.min(width, height) / 2;
                ctx.clearRect(0, 0, width, height);
                
                // Draw background circle to verify full wheel is visible
                ctx.beginPath();
                ctx.arc(width / 2, height / 2, r, 0, Math.PI * 2);
                ctx.fillStyle = '#f0f0f0';
                ctx.fill();
                
                ctx.save();
                ctx.translate(width / 2, height / 2);
                ctx.rotate(rotation);
                const seg = (Math.PI * 2) / jobs.length;
                for (let i = 0; i < jobs.length; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, r - 6, i * seg, (i + 1) * seg);
                    ctx.closePath();
                    ctx.fillStyle = colors[i % colors.length];
                    ctx.fill();

                    ctx.save();
                    ctx.rotate(i * seg + seg / 2);
                    ctx.textAlign = 'right';
                    ctx.fillStyle = '#222';
                    ctx.font = '14px sans-serif';
                    ctx.fillText(jobs[i], r - 18, 5);
                    ctx.restore();
                }
                ctx.restore();

                // pointer
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2, 6);
                ctx.lineTo(canvas.width / 2 - 10, 26);
                ctx.lineTo(canvas.width / 2 + 10, 26);
                ctx.closePath();
                ctx.fillStyle = pointerColor;
                ctx.fill();
            }

            function spin() {
                if (spinning) return;
                spinning = true;
                resultEl.textContent = '';

                const seg = (Math.PI * 2) / jobs.length;
                const targetIndex = Math.floor(Math.random() * jobs.length);
                const targetAngle = -Math.PI / 2 - (targetIndex * seg + seg / 2);
                const current = rotation % (Math.PI * 2);
                const spins = 4 + Math.floor(Math.random() * 2);
                let delta = targetAngle - current + spins * Math.PI * 2;

                const duration = 2200 + Math.random() * 600; // ms
                const start = performance.now();
                const startRot = rotation;

                function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

                function step(now) {
                    const t = Math.min(1, (now - start) / duration);
                    const eased = easeOutCubic(t);
                    rotation = startRot + delta * eased;
                    drawWheel();
                    if (t < 1) requestAnimationFrame(step); else {
                        spinning = false;
                        const landed = ((-rotation - Math.PI / 2) % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2);
                        const index = Math.floor(landed / seg);
                        const picked = jobs[index % jobs.length];
                        resultEl.textContent = `Random job: ${picked}`;
                    }
                }
                requestAnimationFrame(step);
            }

            function scaleForDPR() {
                // Set canvas to exact 400x400 size without DPR scaling
                canvas.width = 400;
                canvas.height = 400;
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                drawWheel();
            }
            window.addEventListener('resize', scaleForDPR);
            scaleForDPR();

            btn.addEventListener('click', spin);
            canvas.addEventListener('click', spin);
        })();
    </script>
    <script>
        // Wheel of Countries
        (function () {
            const canvas = document.getElementById('countryWheel');
            const resultEl = document.getElementById('countryWheelResult');
            const btn = document.getElementById('spinCountryBtn');
            if (!canvas || !resultEl || !btn) return;
            const ctx = canvas.getContext('2d');

            const countries = ['United States','Canada','Mexico','Brazil','United Kingdom','France','Germany','Italy','Spain','Japan','China','India','Australia','South Africa','Egypt'];
            const colors = ['#ff9aa2','#ffb7b2','#ffdac1','#e2f0cb','#b5ead7','#c7ceea',
                            '#ffd666','#95de64','#5cdbd3','#69c0ff','#b37feb','#ffa39e','#ffd8bf','#d6e4ff','#d9f7be'];
            const pointerColor = '#333';

            let rotation = 0; // radians
            let spinning = false;

            function drawWheel() {
                const { width, height } = canvas;
                const r = Math.min(width, height) / 2;
                ctx.clearRect(0, 0, width, height);
                
                // Draw background circle to verify full wheel is visible
                ctx.beginPath();
                ctx.arc(width / 2, height / 2, r, 0, Math.PI * 2);
                ctx.fillStyle = '#f0f0f0';
                ctx.fill();
                
                ctx.save();
                ctx.translate(width / 2, height / 2);
                ctx.rotate(rotation);
                const seg = (Math.PI * 2) / countries.length;
                for (let i = 0; i < countries.length; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, r - 6, i * seg, (i + 1) * seg);
                    ctx.closePath();
                    ctx.fillStyle = colors[i % colors.length];
                    ctx.fill();

                    ctx.save();
                    ctx.rotate(i * seg + seg / 2);
                    ctx.textAlign = 'right';
                    ctx.fillStyle = '#222';
                    ctx.font = '14px sans-serif';
                    const label = countries[i];
                    ctx.fillText(label, r - 18, 5);
                    ctx.restore();
                }
                ctx.restore();

                // pointer
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2, 6);
                ctx.lineTo(canvas.width / 2 - 10, 26);
                ctx.lineTo(canvas.width / 2 + 10, 26);
                ctx.closePath();
                ctx.fillStyle = pointerColor;
                ctx.fill();
            }

            function spin() {
                if (spinning) return;
                spinning = true;
                resultEl.textContent = '';

                const seg = (Math.PI * 2) / countries.length;
                const targetIndex = Math.floor(Math.random() * countries.length);
                const targetAngle = -Math.PI / 2 - (targetIndex * seg + seg / 2);
                const current = rotation % (Math.PI * 2);
                const spins = 4 + Math.floor(Math.random() * 2);
                let delta = targetAngle - current + spins * Math.PI * 2;

                const duration = 2200 + Math.random() * 600; // ms
                const start = performance.now();
                const startRot = rotation;

                function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

                function step(now) {
                    const t = Math.min(1, (now - start) / duration);
                    const eased = easeOutCubic(t);
                    rotation = startRot + delta * eased;
                    drawWheel();
                    if (t < 1) requestAnimationFrame(step); else {
                        spinning = false;
                        const landed = ((-rotation - Math.PI / 2) % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2);
                        const index = Math.floor(landed / seg);
                        const picked = countries[index % countries.length];
                        if (picked === 'Canada') {
                            resultEl.textContent = 'You win! You got Canada!';
                            if (window.launchFireworksBurst) window.launchFireworksBurst();
                        } else {
                            resultEl.textContent = `Random country: ${picked}`;
                        }
                    }
                }
                requestAnimationFrame(step);
            }

            function scaleForDPR() {
                // Set canvas to exact 400x400 size without DPR scaling
                canvas.width = 400;
                canvas.height = 400;
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                drawWheel();
            }
            window.addEventListener('resize', scaleForDPR);
            scaleForDPR();

            btn.addEventListener('click', spin);
            canvas.addEventListener('click', spin);
        })();
    </script>
    <script>
        // Wheel of Animals
        (function () {
            const canvas = document.getElementById('animalWheel');
            const resultEl = document.getElementById('animalWheelResult');
            const btn = document.getElementById('spinWheelBtn');
            if (!canvas || !resultEl || !btn) return;
            const ctx = canvas.getContext('2d');

            const animals = ['Lion','Elephant','Giraffe','Zebra','Tiger','Panda','Kangaroo','Penguin','Fox','Koala','Bear','Monkey','Pig'];
            const colors = ['#ff9aa2','#ffb7b2','#ffdac1','#e2f0cb','#b5ead7','#c7ceea',
                            '#ffd666','#95de64','#5cdbd3','#69c0ff','#b37feb','#ffa39e'];
            const pointerColor = '#333';

            let rotation = 0; // radians
            let spinning = false;

            function drawWheel() {
                const { width, height } = canvas;
                const r = Math.min(width, height) / 2;
                ctx.clearRect(0, 0, width, height);
                
                // Draw background circle to verify full wheel is visible
                ctx.beginPath();
                ctx.arc(width / 2, height / 2, r, 0, Math.PI * 2);
                ctx.fillStyle = '#f0f0f0';
                ctx.fill();
                
                ctx.save();
                ctx.translate(width / 2, height / 2);
                ctx.rotate(rotation);
                const seg = (Math.PI * 2) / animals.length;
                for (let i = 0; i < animals.length; i++) {
                    // slice
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, r - 6, i * seg, (i + 1) * seg);
                    ctx.closePath();
                    ctx.fillStyle = colors[i % colors.length];
                    ctx.fill();

                    // text
                    ctx.save();
                    ctx.rotate(i * seg + seg / 2);
                    ctx.textAlign = 'right';
                    ctx.fillStyle = '#222';
                    ctx.font = '16px sans-serif';
                    ctx.fillText(animals[i], r - 18, 6);
                    ctx.restore();
                }
                ctx.restore();

                // draw pointer (triangle at top center)
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2, 6);
                ctx.lineTo(canvas.width / 2 - 10, 26);
                ctx.lineTo(canvas.width / 2 + 10, 26);
                ctx.closePath();
                ctx.fillStyle = pointerColor;
                ctx.fill();
            }

            function spin() {
                if (spinning) return;
                spinning = true;
                resultEl.textContent = '';

                const seg = (Math.PI * 2) / animals.length;
                const targetIndex = Math.floor(Math.random() * animals.length);
                // We want target segment to land at pointer (angle 0 at top -> we used triangle at top, canvas coordinates start at 3 o'clock angle). For our drawing, pointer at top corresponds to angle -Math.PI/2 in canvas default; but we rotated the wheel then drew pointer in canvas coords after restore, so pointer is fixed at top (y small). The label of segment center aligns with angle 0 at right in draw; but we rotate.
                // Compute target rotation so that segment center aligns with -Math.PI/2 (top)
                const targetAngle = -Math.PI / 2 - (targetIndex * seg + seg / 2);
                const current = rotation % (Math.PI * 2);
                // Add full spins for flair
                const spins = 4 + Math.floor(Math.random() * 2); // 4-5 spins
                let delta = targetAngle - current + spins * Math.PI * 2;

                const duration = 2200 + Math.random() * 600; // ms
                const start = performance.now();
                const startRot = rotation;

                function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

                function step(now) {
                    const t = Math.min(1, (now - start) / duration);
                    const eased = easeOutCubic(t);
                    rotation = startRot + delta * eased;
                    drawWheel();
                    if (t < 1) requestAnimationFrame(step); else {
                        spinning = false;
                        const landed = ((-rotation - Math.PI / 2) % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2);
                        const index = Math.floor(landed / seg);
                        const picked = animals[index % animals.length];
                        if (picked === 'Pig') {
                            resultEl.textContent = 'You win! You got Pig!';
                            if (window.launchFireworksBurst) window.launchFireworksBurst();
                        } else {
                            resultEl.textContent = `Random animal: ${picked}`;
                        }
                    }
                }
                requestAnimationFrame(step);
            }

            // Handle DPR for crisp canvas
            function scaleForDPR() {
                // Set canvas to exact 400x400 size without DPR scaling
                canvas.width = 400;
                canvas.height = 400;
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                drawWheel();
            }
            window.addEventListener('resize', scaleForDPR);
            scaleForDPR();

            btn.addEventListener('click', spin);
            canvas.addEventListener('click', spin);
        })();
    </script>
    <script>
        // Sandwich Predictor logic
        (function () {
            const foods = [
                'Pizza','Burger','Sushi','Tacos','Salad','Pancakes','Waffles','Ramen','Curry','Burrito',
                'Sandwich','Steak','Soup','Ice Cream','Donut','Smoothie','Fries','Paella','Noodles','Dumplings'
            ];
            const img = document.getElementById('sandwichImage');
            const result = document.getElementById('randomFoodResult');
            const upload = document.getElementById('sandwichUpload');
            const uploadBtn = document.getElementById('sandwichUploadBtn');
            if (!img || !result) return;

            function pickRandomFood() {
                const item = foods[Math.floor(Math.random() * foods.length)];
                result.textContent = `Random food: ${item}`;
            }

            img.addEventListener('click', pickRandomFood);
            if (uploadBtn && upload) {
                uploadBtn.addEventListener('click', () => upload.click());
                upload.addEventListener('change', (e) => {
                    const file = e.target.files && e.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = () => {
                        img.src = String(reader.result);
                        result.textContent = '';
                    };
                    reader.readAsDataURL(file);
                });
            }
        })();
    </script>
    <script>
        (function () {
            const btn = document.getElementById('waffleBtn');
            if (btn) {
                btn.addEventListener('click', () => {
                    alert('You ate waffles!');
                });
            }
        })();
    </script>
    <script>
        // Simple T-Rex Runner clone (space/up: jump, down: duck) asdf
        (function () {
            const canvas = document.getElementById('trexCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            const devicePixelRatioValue = window.devicePixelRatio || 1;
            function resizeCanvasForDPR() {
                const cssWidth = canvas.clientWidth;
                const cssHeight = canvas.clientHeight;
                canvas.width = Math.floor(cssWidth * devicePixelRatioValue);
                canvas.height = Math.floor(cssHeight * devicePixelRatioValue);
                ctx.setTransform(devicePixelRatioValue, 0, 0, devicePixelRatioValue, 0, 0);
            }
            resizeCanvasForDPR();
            window.addEventListener('resize', resizeCanvasForDPR);

            const groundY = 180; // in CSS pixels
            const gravity = 0.9;
            const jumpVelocity = -15.625;
            const duckScale = 0.6;
            const initialSpeed = 6;
            const maxSpeed = 13;

            let lastTime = 0;
            let gameRunning = false;
            let gameOver = false;
            let speed = initialSpeed;
            let score = 0;
            let highScore = parseInt(localStorage.getItem('trexHighScore') || '0', 10);

            const player = {
                x: 50,
                y: groundY,
                width: 44,
                height: 48,
                vy: 0,
                onGround: true,
                ducking: false,
            };

            // Load pig image
            const pigImg = new Image();
            pigImg.src = 'public/pig_mirrored_transparent_cropped.png';

            const obstacles = [];
            let obstacleTimer = 0;
            const obstacleIntervalMin = 550; // ms
            const obstacleIntervalMax = 1100; // ms
            let nextObstacleIn = randomRange(obstacleIntervalMin, obstacleIntervalMax);

            // Load obstacle images
            const wolfImg = new Image();
            wolfImg.src = 'public/wolf_transparent_cropped_mirrored.png';
            const bushImg = new Image();
            bushImg.src = 'public/blueberry_bush_pixel.png';

            const clouds = [];
            let cloudTimer = 0;
            const cloudInterval = 1600;

            function randomRange(min, max) {
                return Math.floor(min + Math.random() * (max - min));
            }

            function resetGame() {
                gameRunning = false;
                gameOver = false;
                speed = initialSpeed;
                score = 0;
                player.y = groundY;
                player.vy = 0;
                player.onGround = true;
                player.ducking = false;
                obstacles.length = 0;
                clouds.length = 0;
                obstacleTimer = 0;
                nextObstacleIn = randomRange(obstacleIntervalMin, obstacleIntervalMax);
                cloudTimer = 0;
            }

            function spawnObstacle() {
                const obstacleTypes = [
                    { type: 'wolf', w: 40, h: 60 },
                    { type: 'bush', w: 35, h: 25 },
                ];
                const obstacle = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                obstacles.push({ 
                    x: canvas.clientWidth + 20, 
                    y: groundY - obstacle.h, 
                    w: obstacle.w, 
                    h: obstacle.h,
                    type: obstacle.type
                });
            }

            function spawnCloud() {
                const y = 20 + Math.random() * 80;
                const s = 0.5 + Math.random() * 0.8;
                clouds.push({ x: canvas.clientWidth + 10, y, speed: s });
            }

            function rectsIntersect(a, b) {
                return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
            }

            function update(dt) {
                if (!gameRunning) return;

                // Speed increases slowly
                speed = Math.min(maxSpeed, speed + dt * 0.0007);
                score += dt * 0.01 * speed;

                // Player physics
                player.vy += gravity;
                player.y += player.vy;
                const currentHeight = player.ducking ? player.height * duckScale : player.height;
                if (player.y >= groundY) {
                    player.y = groundY;
                    player.vy = 0;
                    player.onGround = true;
                } else {
                    player.onGround = false;
                }

                // Obstacles
                obstacleTimer += dt;
                if (obstacleTimer >= nextObstacleIn) {
                    spawnObstacle();
                    obstacleTimer = 0;
                    nextObstacleIn = randomRange(obstacleIntervalMin, obstacleIntervalMax);
                }
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    obstacles[i].x -= speed;
                    if (obstacles[i].x + obstacles[i].w < -10) obstacles.splice(i, 1);
                }

                // Clouds (parallax)
                cloudTimer += dt;
                if (cloudTimer >= cloudInterval) {
                    spawnCloud();
                    cloudTimer = 0;
                }
                for (let i = clouds.length - 1; i >= 0; i--) {
                    clouds[i].x -= clouds[i].speed * speed * 0.35;
                    if (clouds[i].x < -60) clouds.splice(i, 1);
                }

                // Collision
                const playerRect = {
                    x: player.x,
                    y: player.y - (player.ducking ? currentHeight : player.height),
                    w: player.width,
                    h: player.ducking ? currentHeight : player.height,
                };
                for (let i = 0; i < obstacles.length; i++) {
                    if (rectsIntersect(playerRect, obstacles[i])) {
                        gameOver = true;
                        gameRunning = false;
                        highScore = Math.max(highScore, Math.floor(score));
                        localStorage.setItem('trexHighScore', String(highScore));
                        break;
                    }
                }
            }

            function draw() {
                // Clear
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Sky background tint in dark mode for subtle effect handled by CSS

                // Clouds
                ctx.fillStyle = 'rgba(0,0,0,0.15)';
                clouds.forEach(c => {
                    drawCloud(c.x, c.y);
                });

                // Ground line
                ctx.strokeStyle = 'rgba(0,0,0,0.25)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, groundY + 1);
                ctx.lineTo(canvas.clientWidth, groundY + 1);
                ctx.stroke();

                // Obstacles
                obstacles.forEach(o => {
                    if (o.type === 'wolf' && wolfImg.complete && wolfImg.naturalWidth) {
                        ctx.drawImage(wolfImg, o.x, o.y, o.w, o.h);
                    } else if (o.type === 'bush' && bushImg.complete && bushImg.naturalWidth) {
                        ctx.drawImage(bushImg, o.x, o.y, o.w, o.h);
                    } else {
                        // Fallback to rectangle if image not loaded
                        ctx.fillStyle = '#555';
                        ctx.fillRect(o.x, o.y, o.w, o.h);
                    }
                });

                // Player
                const currentHeight = player.ducking ? player.height * duckScale : player.height;
                if (pigImg.complete && pigImg.naturalWidth) {
                    ctx.drawImage(pigImg, player.x, player.y - currentHeight, player.width, currentHeight);
                } else {
                    ctx.fillStyle = '#222';
                    ctx.fillRect(player.x, player.y - currentHeight, player.width, currentHeight);
                }

                // Score
                ctx.fillStyle = '#333';
                ctx.font = '16px monospace';
                const scoreText = `Score: ${Math.floor(score).toString().padStart(5, '0')}  High: ${highScore.toString().padStart(5, '0')}`;
                ctx.fillText(scoreText, canvas.clientWidth - ctx.measureText(scoreText).width - 10, 20);

                if (!gameRunning && !gameOver) {
                    drawCenteredText('Press Space to start', groundY - 40);
                }
                if (gameOver) {
                    drawCenteredText('Game Over - Press Space to restart', groundY - 40);
                }
            }

            function drawCenteredText(text, y) {
                ctx.fillStyle = '#444';
                ctx.font = '18px monospace';
                const w = ctx.measureText(text).width;
                ctx.fillText(text, (canvas.clientWidth - w) / 2, y);
            }

            function drawCloud(x, y) {
                ctx.beginPath();
                ctx.arc(x, y, 10, Math.PI * 0.5, Math.PI * 1.5);
                ctx.arc(x + 15, y - 10, 15, Math.PI * 1, Math.PI * 1.85);
                ctx.arc(x + 30, y, 10, Math.PI * 1.5, Math.PI * 0.5);
                ctx.closePath();
                ctx.fill();
            }

            function loop(timestamp) {
                if (!lastTime) lastTime = timestamp;
                const dt = timestamp - lastTime;
                lastTime = timestamp;
                update(dt);
                draw();
                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);

            function startOrJump() {
                if (!gameRunning && !gameOver) {
                    gameRunning = true;
                    return;
                }
                if (gameOver) {
                    resetGame();
                    gameRunning = true;
                    return;
                }
                if (player.onGround) {
                    player.vy = jumpVelocity;
                    player.onGround = false;
                }
            }

            function handleKeyDown(e) {
                if (e.code === 'Space' || e.code === 'ArrowUp') {
                    e.preventDefault();
                    startOrJump();
                } else if (e.code === 'ArrowDown') {
                    player.ducking = true;
                }
            }
            function handleKeyUp(e) {
                if (e.code === 'ArrowDown') {
                    player.ducking = false;
                }
            }

            // Input listeners
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);

            // Focus canvas on click for accessibility
            canvas.addEventListener('click', () => canvas.focus());
        })();
    </script>
    
</body>
</html>